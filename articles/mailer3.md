реализации

1 Приципиальная архитектура
2 Выбор записи из очередей
3 Токены
4 Аналитика
5 Персонализированные письма
6 A\b тестирование

Поясню UML диаграмму. Крон запускает скрипт, который читает из БД первую очередь, которую нужно отправить. После этого очередь запрашивает список очередной партии получателей, после этого запрашивает само письмо, которое нужно отправить. Данные о письме передаются в объект генератор текста письма, который создаст текст для пользователя. После этого эти данные передаются в специальный объект Mailer,который уже управляет самим процессом.
 
 В процессе Mailer для каждого пользователя получается его индивидуальное письмо и оно отправляется.
 
 Достаточно интересным моментом является выбор списка по которому будет рассылаться. У каждой записи в таблице Queue есть два статуса wait и sending и время старта. Первый означает что данный список ждет своей очереди, второй что список уже начал рассылаться. Код который выбирает очередной список берет в первую очередь те записи, у которых статус  sending.
 
 Смотря и анализируя это поведение я считаю, что такой выбор записей - это крайне неудачное решение. Такая выборка обеспечивает максимально быструю рассылку каждого письма. Фактически письма становятся в очередь друг за другом. Это очень удобно при разработке. Но с точки зрения бизнеса - это неудачно. При таком способе рассылки, после каждой рассылки возникает резкий пик прихода на сайт новых посетителей. Это создает нагрузку на инфраструктуру. Более верным решением является максимально размазать нагрузку, то есть при каждой выборке выбирать один список из тех что нужно разослать случайным образом. Таким способом будет увеличено среднее время рассылки каждого письма и соответственно размазан пик нагрузки на инфраструктуру.
 
 Следующее важное место - это аналитика. Для разных писем, нужна разная аналитика, кроме того иногда для чистоты данных систему аналитики вообще нужно отключать. Фактически вся аналитика основывается на изменении ссылок, которые есть в письме. Изменения могут быть 2 видов:
 - Проксируем ссылку через сервер
 - Добавляем к ссылке параметры, для отслеживания внешней системой аналитики
 
 Для того чтобы удовлетворить требования была сделана небольшая уловка: так как письмо собирается из блоков, то подменились те ссылки, которые были в каждом из блоков. При этом настройки как менять ссылку хранятся в полях самого письма. Сам код который подменяет ссылки упрощенно выглядит следующим образом:
  ```
   Код замены ссылки
  ```
 То есть скрипт берет ссылку и последовательно проделывает манипуляции. Если конкретное действие не нужно, то шаг пропускает и идет к следующему. При этом порядок манипуляций строгий.
 
 На самом деле реализация которую я привожу является весьма простой, понятной и некорректной. Идея с порядком манипулций - верная и позволяет съкономить кучу времени при отладке. Но вот идея, что мы можем обертывать ссылки из блоков - оказалась неверной. Достаточно много получателей нажимают на лейаут письма. Более верным решением сейчас мне кажется идея регулярным выражением распарсить уже сформированное письмо и пропустить каждую ссылку через ссылко менятель
 
 Следующее важное место это токены. Токены - это значения, которые подставляются. Через использование токенов делается обращение в письме например.