В прошллой части я дал общее описание системы. Сеййчас я расскажу почему система была сделана именно так.
 
 Подключение дополнительных полей через доп таблицу. Самым большим недостатком данного решения является то что эта таблица начинает весьма и весьма сильно разрастаться. Потенциально это может создавать проблемы с быстродействием. С другой стороны большим плюсом данного решения является возможность просто делать запросы по значению в дополнительных полях ( конечно это обходится нам в один join). Альтернативно, дополнительные поля можно складывать в поле типа json или сериализованное поле. Однако в mysql при этом простоты в воборке по этому полю не будет. 
 
 NB Если выбрать в качестве БД postgresql, то в нем можно будет и складывать в json и делать выборки по этому полю и даже построить индексы. 
 
 Мы никогда не удаляем записи юзеровю. Удалять записи - это достаточно неприятная процедура, ведь кроме удаления самой записи возникает вопрос как корректно обработать все вхоождения этого юзера, например в статистику. Поэтому мы и используем статусы у юзеров и просто помечаем подписчика удаленным. Так же через статусы помечается источник откуда добавился подписчик в систему. Это можно было сделать через дополнительное поле источник, но за счет статусов мы можем более просто добавить разное поведение для разных типов подписчиков ( например не слать рекламную информацию тем, кто давал свои контакты нам на личных встречах) 
 
 Система очереди является одним из самых спорных мест в системе. Во первых их можно было бы сделать за счет какого либо MQ-решения. Но в системе очередь реализована через БД, для того чтобы позволить очереди быть более переменной, то есть отправки сообщений в очереди может меняться в зависимости от нагрузки и пожеланий администраторов системы. В самой очереди хранятся не сообщения, а объекты которые должны быть обработаны .Это могут быть или одно пиьсом или одно сообщение. В осномном хрянятся не сообщения, которые должны отправиться, а только количество отправленных сообщений из нужной очереди по выбранному письму.
  Это появилось как требование сонкратить размер БД, которая будет работать с системой. С другой стороны для большинства писем это отлично подходит. В основном нас интересует разослать письмо по всем кто находится в определенном сипске. Поэтому мы можем отсортировать всех подписчиков по дате добавления, отправить группу писем например 100 и пометить что мы отправили 100 писем, потом отправить еще 100 и пометить что мы отправили 200 писем. Так мы разошлем все письма. Если во время рассылки будет добавлен новый человек, то его дата добавление поставит его в конец списка и он так же получит письмо. Окончанием рассылки письма является момент когда все очереди окончились, то есть при исчерпании списка мы проверяем статус у каждой очереди. Если статус всех очередей Завершено, то мы ставим письму статус разослано. Если хотя бы у одной очереди статс не Завершено. То мы просто ставим у очереди новый статус. Окончанием рассылки конкретной очереди является выборка из БД следующего набора подписчиков. который будет меньше по объему чем коичество которое мы планировали выбрать. (например если мы хотели выбрать очередные 100 подписчиков, а выбрали только 50, то это значит что в системе больше нет невыбранных подписчиков и значит можно поставить что очередь завершилась). 
  
 Для сбора статистики мы используем проксирующий сервер. То есть когда человек нажимает на ссылку, он переходит к нам, мы записываем все данные этого человека - и после этого мы перенаправляем его на целевую страницу. Для сбора данных об открытии письма мы используем пустую картинку размером 1 на 1 пиксель, чей урл мы так же проксируем. Для сбора данных о недоставленных письмах мы используем логи почтового сервера. Если вы шлете письмо. и оно уходит на неверный адресс, то оно вренется и можно по этим данным сказать что письмо недоставлено. С другой стороны, когда вы шлете через postfix у вас есть его логи, они хранятся в файлах и значительно проще и быстрее выбрать информацию из этих логов чем подключаться к почте. При работе с логами возникает вопрос, как гарантироано понять письмо из какой рассылки не ушло. В логах вы будете видеть email, но вам нужно еще совместить его с нужной рассылкой. В принципе как один из вариантов в лоб, если у вас не часто идут рассылки, совмещать по времени. Скорее всего если на почту не пришло одно письмо, то и остальные не придут и можно помечать все письма как недоставленные. Однако есть слегка более сложный но более точный путь. У каждого письма есть заголовок """"""ю В этом заголовке содержится уникальный идентификатор письма. И это заголовок постфикс по умолчанию пишет в свои логи. Если вы подмените заголовок на что-то такое ЭЭЭЭЭЭЭ, то при распарсениии вы увидете не только письмо, но и еще расслку для которой письмо было не доставлено. При этом если сделать заголовок не соответствующий формату, то постфикс отбросит его и заменит на нормальный. Таким образом у получателей заголовок будет не отображаться.
 