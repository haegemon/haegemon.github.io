# О транзакциях deferred constraint и
 
 В мануале к yii приводится следующий код
 ```
 Yii::app()->db->createCommand("SET CONSTRAINTS ALL DEFERRED;")->execute();
 
 $transaction=$connection->beginTransaction();
 try
 {
     $connection->createCommand($sql1)->execute();
     $connection->createCommand($sql2)->execute();
     //… прочие SQL-запросы
     $transaction->commit();
 }
 catch(Exception $e) // в случае возникновения ошибки при выполнении одного из запросов выбрасывается исключение
 {
     $transaction->rollback();
 }
 ```
 Сам код не вызывает вопросов: мы открываем транзакцию, выполняем комманды, если все хорошо, то комитем транзацию, если нет , то откатываем транзакцию. Вроде бы все логично. 
 
 В моей работе мы используем распределенную инфраструктуру. При этом возникает вопрос про синхронизацию данных между различными сущностями. Изначально отвественность за синхронизацию лежала на разработчиках. В какой то момент появилось время и необходимость перевести синхронизацию в автоматический режим.
 В проекте существует таблица с областями. Таблица содержит данные по региону. Обычно регионы с которыми работаем только добавляются и исключительно редко регион может исключаться из схемы.
 
 Первичный ключ данной таблицы используется в других таблицах, так что наложены внешние ключи.
 
 Была выбрана следующая схема обновления:
 1) Запускаем транзакцию
 2) Сообщаем базе данных, что ключи нужно проверить при закрытии транзации
 3) Удаляем все из таблицы
 4) Записываем в нее новые данные
 5) Комитем транзакцию
 
 После старта скрипта получаем 2 ошибки:
 
 ```
 SQLSTATE[23503]: Foreign key violation: 7 ОШИБКА:  UPDATE или DELETE в таблице "region" нарушает ограничение внешнего ключа 
 
 exception 'PDOException' with message 'There is no active transaction' 
 ```
 
 Первая ошибка понятна. В существующей системе все же записи, которые ведут на регионы, которые больше не поддерживаютсяю
 А вот вторая ошибка вызывает вопросы: фактически она означает следующее в блоке try произощла ошибка, при этом когда выполнялся код catch транзакция на уровне pdo уже не существует. Что интересно - транзакция на уровне yii еще есть.
 
 Изначальное предположение было о том, что система не смогла поставить транзакцию. Небольшой проверки  оказалось достаточно, чтобы убедиться что это не так. Вариант о том что пдо сама отменяет транзакцию при опереции так же отмел, как не имеющую смысла, иначе весь механизм транзакций в уии окажется скомпроментированным. После некоторого раздумья я пришел к единственному возможному варианту, что транзакцию отменяет коммит. Осталось понять почему так: 
 при коммите должна происходить фиксирование действий транзакции в БД. Но так как мы отложили проверку внешних ключей до комита транзакции, то проверка запускается при комите. Проверка получается неразрывна связана с комитом. именно Она отменяет гененрирует исключение в Бд, отменяет транзакцию и при этом отдает исключение в БД. На мой взгляд более логичным было бы если бы транзакция при такой проверки не отменялась сама. но в остальном поведение очень логичное. 
 
 Чтобы привести код в надлежащее состояние есть 3 варианта:
 1) Опасный: Поставить собачку перед rollback. В общем то как временная замена вполе даже сработает
 Лучше сделать честный код
 для каждой пришежшей записи проверить есть ли он
 если ее нет, тосоздать ее если есть то обновить
 еси в БД есь записи которые не пришли, то просигнализировать о них администратору.